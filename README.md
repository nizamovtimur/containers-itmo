# Лабораторная работа №1 (Dockerfile) по курсу ИТМО "Контейнеризация и оркестрация приложений"

**Авторы:** Неронов Роман, Низамов Тимур — AI Talent Hub

## Описание

В данном репозитории представлены два Dockerfile для сервиса QA: один демонстрирует плохие практики контейнеризации (`bad.Dockerfile`), а другой — лучшие практики (`good.Dockerfile`). Также содержатся описания неправильных сценариев использования контейнеризации.

## Содержимое Репозитория

- `bad.Dockerfile`: Пример Dockerfile с плохими практиками.
- `good.Dockerfile`: Пример Dockerfile, соответствующий лучшим практикам.
- `qa/`: Исходный код QA сервиса.
  - `.env.example`: Пример файла переменных окружения.
  - `config.py`, `database.py`, `llm_prompting.py`, `main.py`: Конфигурационные и функциональные модули.
  - `requirements.txt`: Зависимости проекта.
- `README.md`: Данный файл с описанием проекта.

## Dockerfile'ы

### 1. Плохой Dockerfile (`bad.Dockerfile`)

**Проблемы:**
- **Тяжелый базовый образ:** Используется полный образ `python:3.10.0`, что увеличивает размер конечного образа.
- **Установка ненужных пакетов:** Устанавливаются `git` и `build-essential`, даже если они не требуются для запуска приложения.
- **Отсутствие очистки кеша:** Установленные пакеты не удаляются из кеша, что увеличивает размер образа.
- **Запуск от имени root:** Приложение запускается с привилегиями суперпользователя, что повышает риски безопасности.
- **Неэффективная организация слоёв:** Установка зависимостей происходит до копирования основного кода, что мешает эффективному кэшированию слоёв.

### 2. Хороший Dockerfile (`good.Dockerfile`)

**Преимущества:**
- **Легковесный базовый образ с фиксированной версией:** Используется `python:3.10.0-slim-buster`, что уменьшает размер и обеспечивает стабильность.
- **Создание нетривиального пользователя:** Приложение запускается от имени `app`, повышая безопасность.
- **Оптимизированная установка зависимостей:** Устанавливаются только необходимые пакеты с использованием `--no-install-recommends` и очищается кеш.
- **Эффективная организация слоёв:** Сначала копируется `requirements.txt` и устанавливаются зависимости, что позволяет использовать кэширование слоёв при повторных сборках.
- **Добавление HEALTHCHECK:** Мониторинг состояния приложения.
- **Очистка кеша и удаление ненужных пакетов:** Уменьшает размер образа и улучшает безопасность.
- **Использование `--no-cache-dir` при установке Python-зависимостей:** Предотвращает кеширование пакетов pip, уменьшая размер образа.

## Плохие Практики Использования Контейнеров

1. **Чрезмерное использование контейнеров для простых задач**

   Усложнение развертывания и управления без существенных преимуществ.

2. **Неоптимальная организация слоёв Docker**

   Неправильное разделение команд `RUN`, `COPY` и других может приводить к увеличению времени сборки и размера образа из-за отсутствия эффективного кэширования слоёв.

3. **Отсутствие управления зависимостями и версиями**

   Установка зависимостей без фиксации версий приводит к непредсказуемому поведению приложения из-за возможных несовместимостей и изменений в будущих версиях библиотек.

## Когда Не Стоит Использовать Контейнеры

1. **Высокопроизводительные вычисления**

   Дополнительный уровень абстракции может вызвать задержки.

2. **Приложения, требующие специфических версий операционной системы или нестандартных системных конфигураций**

   Контейнеризация может быть ограничена стандартными образами, и настройка специфических версий ОС или системных параметров может быть трудоемкой или невозможной.

## Логирование

Логи сохраняются в `/app/logs`, монтируемом как volume для сохранения вне контейнера. Это обеспечивает сохранность логов даже при перезапуске или удалении контейнера.

## Установка и Запуск

### Сборка Образов

Сначала выполните сборку образов для обоих Dockerfile'ов.

#### Сборка плохого Dockerfile
```bash
docker build -t qa-service:bad -f bad.Dockerfile .
```
#### Сборка хорошего Dockerfile
```bash
docker build -t qa-service:good -f good.Dockerfile .
```

### Запуск Контейнеров

Запустите контейнеры, привязав порт `8080` и смонтировав директорию для логов.

#### Запуск контейнера с плохим Dockerfile
```bash
docker run -d \
      -p 8080:8080 \
      -v $(pwd)/logs:/app/logs \
      --name qa-bad \
      qa-service:bad
```
#### Запуск контейнера с хорошим Dockerfile
```bash
docker run -d \
      -p 8080:8080 \
      -v $(pwd)/logs:/app/logs \
      --name qa-good \
      qa-service:good
```

## Тестирование

1. **Отправка запроса:**

   Отправьте POST-запрос на эндпоинт `/qa/` с вопросом.

   ### Пример Запроса

   ```bash
   curl -X POST http://localhost:8080/qa/ \
        -H "Content-Type: application/json" \
        -d '{"question": "Что такое метафизика у Аристотеля?"}'
   ```

2. **Ожидаемый Ответ:**

   Если всё настроено корректно, вы получите JSON-ответ с найденными фрагментами или генерированным ответом.

   ```json
   {
     "answer": "Найденные фрагменты из источника."
   }
   ```